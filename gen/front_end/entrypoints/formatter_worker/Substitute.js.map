{"version":3,"file":"Substitute.js","sourceRoot":"","sources":["../../../../../../front_end/entrypoints/formatter_worker/Substitute.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Acorn from '../../third_party/acorn/acorn.js';\n\nimport {ECMA_VERSION} from './AcornTokenizer.js';\n\nexport function substituteExpression(expression: string, nameMap: Map<string, string>): string {\n  const replacements = computeSubstitution(expression, nameMap);\n  return applySubstitution(expression, replacements);\n}\n\ninterface Replacement {\n  from: string;\n  to: string;\n  offset: number;\n  isShorthandAssignmentProperty: boolean;\n}\n\n// Given an |expression| and a mapping from names to new names, the |computeSubstitution|\n// function returns a list of replacements sorted by the offset. The function throws if\n// it cannot parse the expression or the substitution is impossible to perform (for example\n// if the substitution target is 'this' within a function, it would become bound there).\nfunction computeSubstitution(expression: string, nameMap: Map<string, string>): Replacement[] {\n  // Parse the expression and find variables and scopes.\n  const root = Acorn.parse(expression, {ecmaVersion: ECMA_VERSION, allowAwaitOutsideFunction: true, ranges: false}) as\n      Acorn.ESTree.Node;\n  const scopeVariables = new ScopeVariableAnalysis();\n  scopeVariables.processNode(root);\n  const freeVariables = scopeVariables.getFreeVariables();\n  const result: Replacement[] = [];\n\n  // Prepare the machinery for generating fresh names (to avoid variable captures).\n  const allNames = scopeVariables.getAllNames();\n  for (const rename of nameMap.values()) {\n    allNames.add(rename);\n  }\n  function getNewName(base: string): string {\n    let i = 1;\n    while (allNames.has(`${base}_${i}`)) {\n      i++;\n    }\n    const newName = `${base}_${i}`;\n    allNames.add(newName);\n    return newName;\n  }\n\n  // Perform the substitutions.\n  for (const [name, rename] of nameMap.entries()) {\n    const defUse = freeVariables.get(name);\n    if (!defUse) {\n      continue;\n    }\n\n    const binders = [];\n    for (const use of defUse) {\n      result.push({\n        from: name,\n        to: rename,\n        offset: use.offset,\n        isShorthandAssignmentProperty: use.isShorthandAssignmentProperty,\n      });\n      binders.push(...use.scope.findBinders(rename));\n    }\n    // If there is a capturing binder, rename the bound variable.\n    for (const binder of binders) {\n      if (binder.definitionKind === DefinitionKind.Fixed) {\n        // If the identifier is bound to a fixed name, such as 'this',\n        // then refuse to do the substitution.\n        throw new Error(`Cannot avoid capture of '${rename}'`);\n      }\n      const newName = getNewName(rename);\n      for (const use of binder.uses) {\n        result.push({\n          from: rename,\n          to: newName,\n          offset: use.offset,\n          isShorthandAssignmentProperty: use.isShorthandAssignmentProperty,\n        });\n      }\n    }\n  }\n  result.sort((l, r) => l.offset - r.offset);\n  return result;\n}\n\nfunction applySubstitution(expression: string, replacements: Replacement[]): string {\n  const accumulator = [];\n  let last = 0;\n  for (const r of replacements) {\n    accumulator.push(expression.slice(last, r.offset));\n    let replacement = r.to;\n    if (r.isShorthandAssignmentProperty) {\n      // Let us expand the shorthand to full assignment.\n      replacement = `${r.from}: ${r.to}`;\n    }\n    accumulator.push(replacement);\n    last = r.offset + r.from.length;\n  }\n  accumulator.push(expression.slice(last));\n  return accumulator.join('');\n}\n\ninterface Use {\n  offset: number;\n  scope: Scope;\n  isShorthandAssignmentProperty: boolean;\n}\n\nconst enum DefinitionKind {\n  None = 0,\n  Let = 1,\n  Var = 2,\n  Fixed = 3,\n}\n\ninterface VariableUses {\n  definitionKind: DefinitionKind;\n  uses: Use[];\n}\n\nclass Scope {\n  readonly variables = new Map<string, VariableUses>();\n  readonly parent: Scope|null;\n\n  constructor(parent: Scope|null) {\n    this.parent = parent;\n  }\n\n  addVariable(name: string, offset: number, definitionKind: DefinitionKind, isShorthandAssignmentProperty: boolean):\n      void {\n    const variable = this.variables.get(name);\n    const use = {offset, scope: this, isShorthandAssignmentProperty};\n    if (!variable) {\n      this.variables.set(name, {definitionKind, uses: [use]});\n      return;\n    }\n    if (variable.definitionKind === DefinitionKind.None) {\n      variable.definitionKind = definitionKind;\n    }\n    variable.uses.push(use);\n  }\n\n  findBinders(name: string): VariableUses[] {\n    const result = [];\n    let scope: Scope|null = this;\n    while (scope !== null) {\n      const defUse = scope.variables.get(name);\n      if (defUse && defUse.definitionKind !== DefinitionKind.None) {\n        result.push(defUse);\n      }\n      scope = scope.parent;\n    }\n    return result;\n  }\n\n  #mergeChildDefUses(name: string, defUses: VariableUses): void {\n    const variable = this.variables.get(name);\n    if (!variable) {\n      this.variables.set(name, defUses);\n      return;\n    }\n    variable.uses.push(...defUses.uses);\n    if (defUses.definitionKind === DefinitionKind.Var) {\n      console.assert(variable.definitionKind !== DefinitionKind.Let);\n      if (variable.definitionKind === DefinitionKind.None) {\n        variable.definitionKind = defUses.definitionKind;\n      }\n    } else {\n      console.assert(defUses.definitionKind === DefinitionKind.None);\n    }\n  }\n\n  finalizeToParent(isFunctionScope: boolean): void {\n    if (!this.parent) {\n      console.error('Internal error: wrong nesting in scope analysis.');\n      throw new Error('Internal error');\n    }\n\n    // Move all unbound variables to the parent (also move var-bound variables\n    // if the parent is not a function).\n    const keysToRemove = [];\n    for (const [name, defUse] of this.variables.entries()) {\n      if (defUse.definitionKind === DefinitionKind.None ||\n          (defUse.definitionKind === DefinitionKind.Var && !isFunctionScope)) {\n        this.parent.#mergeChildDefUses(name, defUse);\n        keysToRemove.push(name);\n      }\n    }\n    keysToRemove.forEach(k => this.variables.delete(k));\n  }\n}\n\nclass ScopeVariableAnalysis {\n  readonly #rootScope = new Scope(null);\n  readonly #allNames = new Set<string>();\n  #currentScope = this.#rootScope;\n\n  processNode(node: Acorn.ESTree.Node|null): void {\n    if (node === null) {\n      return;\n    }\n    switch (node.type) {\n      case 'AwaitExpression':\n        this.processNode(node.argument);\n        break;\n      case 'ArrayExpression':\n        node.elements.forEach(item => this.processNode(item));\n        break;\n      case 'ExpressionStatement':\n        this.processNode(node.expression);\n        break;\n      case 'Program':\n        console.assert(this.#currentScope === this.#rootScope);\n        node.body.forEach(item => this.processNode(item));\n        console.assert(this.#currentScope === this.#rootScope);\n        break;\n      case 'ArrayPattern':\n        node.elements.forEach(item => this.processNode(item));\n        break;\n      case 'ArrowFunctionExpression':\n        this.#pushScope();\n        node.params.forEach(this.#processNodeAsDefinition.bind(this, DefinitionKind.Var));\n        this.processNode(node.body);\n        this.#popScope(true);\n        break;\n      case 'AssignmentExpression':\n      case 'AssignmentPattern':\n      case 'BinaryExpression':\n      case 'LogicalExpression':\n        this.processNode(node.left);\n        this.processNode(node.right);\n        break;\n      case 'BlockStatement':\n        this.#pushScope();\n        node.body.forEach(this.processNode.bind(this));\n        this.#popScope(false);\n        break;\n      case 'CallExpression':\n        this.processNode(node.callee);\n        node.arguments.forEach(this.processNode.bind(this));\n        break;\n      case 'VariableDeclaration': {\n        const definitionKind = node.kind === 'var' ? DefinitionKind.Var : DefinitionKind.Let;\n        node.declarations.forEach(this.#processVariableDeclarator.bind(this, definitionKind));\n        break;\n      }\n      case 'CatchClause':\n        this.#pushScope();\n        this.#processNodeAsDefinition(DefinitionKind.Let, node.param);\n        node.body.body.forEach(this.processNode.bind(this));\n        this.#popScope(false);\n        break;\n      case 'ClassBody':\n        node.body.forEach(this.processNode.bind(this));\n        break;\n      case 'ClassDeclaration':\n        this.#processNodeAsDefinition(DefinitionKind.Let, node.id);\n        this.#pushScope();\n        this.processNode(node.superClass ?? null);\n        this.processNode(node.body);\n        this.#popScope(false);\n        break;\n      case 'ClassExpression':\n        this.#pushScope();\n        // Intentionally ignore the id.\n        this.processNode(node.superClass ?? null);\n        this.processNode(node.body);\n        this.#popScope(false);\n        break;\n      case 'ChainExpression':\n        this.processNode(node.expression);\n        break;\n      case 'ConditionalExpression':\n        this.processNode(node.test);\n        this.processNode(node.consequent);\n        this.processNode(node.alternate);\n        break;\n      case 'DoWhileStatement':\n        this.processNode(node.body);\n        this.processNode(node.test);\n        break;\n      case 'ForInStatement':\n      case 'ForOfStatement':\n        this.#pushScope();\n        this.processNode(node.left);\n        this.processNode(node.right);\n        this.processNode(node.body);\n        this.#popScope(false);\n        break;\n      case 'ForStatement':\n        this.#pushScope();\n        this.processNode(node.init ?? null);\n        this.processNode(node.test ?? null);\n        this.processNode(node.update ?? null);\n        this.processNode(node.body);\n        this.#popScope(false);\n        break;\n      case 'FunctionDeclaration':\n        this.#processNodeAsDefinition(DefinitionKind.Var, node.id);\n        this.#pushScope();\n        this.#addVariable('this', node.start, DefinitionKind.Fixed);\n        this.#addVariable('arguments', node.start, DefinitionKind.Fixed);\n        node.params.forEach(this.#processNodeAsDefinition.bind(this, DefinitionKind.Let));\n        this.processNode(node.body);\n        this.#popScope(true);\n        break;\n      case 'FunctionExpression':\n        // Id is intentionally ignored in function expressions.\n        this.#pushScope();\n        this.#addVariable('this', node.start, DefinitionKind.Fixed);\n        this.#addVariable('arguments', node.start, DefinitionKind.Fixed);\n        node.params.forEach(this.#processNodeAsDefinition.bind(this, DefinitionKind.Let));\n        this.processNode(node.body);\n        this.#popScope(true);\n        break;\n      case 'Identifier':\n        this.#addVariable(node.name, node.start);\n        break;\n      case 'IfStatement':\n        this.processNode(node.test);\n        this.processNode(node.consequent);\n        this.processNode(node.alternate ?? null);\n        break;\n      case 'LabeledStatement':\n        this.processNode(node.body);\n        break;\n      case 'MetaProperty':\n        break;\n      case 'MethodDefinition':\n        if (node.computed) {\n          this.processNode(node.key);\n        }\n        this.processNode(node.value);\n        break;\n      case 'NewExpression':\n        this.processNode(node.callee);\n        node.arguments.forEach(this.processNode.bind(this));\n        break;\n      case 'MemberExpression':\n        this.processNode(node.object);\n        if (node.computed) {\n          this.processNode(node.property);\n        }\n        break;\n      case 'ObjectExpression':\n        node.properties.forEach(this.processNode.bind(this));\n        break;\n      case 'ObjectPattern':\n        node.properties.forEach(this.processNode.bind(this));\n        break;\n      case 'PrivateIdentifier':\n        break;\n      case 'PropertyDefinition':\n        if (node.computed) {\n          this.processNode(node.key);\n        }\n        this.processNode(node.value ?? null);\n        break;\n      case 'Property':\n        if (node.shorthand) {\n          console.assert(node.value === node.key);\n          console.assert(node.value.type === 'Identifier');\n          this.#addVariable((node.value as Acorn.ESTree.Identifier).name, node.value.start, DefinitionKind.None, true);\n        } else {\n          if (node.computed) {\n            this.processNode(node.key);\n          }\n          this.processNode(node.value);\n        }\n        break;\n      case 'RestElement':\n        this.#processNodeAsDefinition(DefinitionKind.Let, node.argument);\n        break;\n      case 'ReturnStatement':\n        this.processNode(node.argument ?? null);\n        break;\n      case 'SequenceExpression':\n        node.expressions.forEach(this.processNode.bind(this));\n        break;\n      case 'SpreadElement':\n        this.processNode(node.argument);\n        break;\n      case 'SwitchCase':\n        this.processNode(node.test ?? null);\n        node.consequent.forEach(this.processNode.bind(this));\n        break;\n      case 'SwitchStatement':\n        this.processNode(node.discriminant);\n        node.cases.forEach(this.processNode.bind(this));\n        break;\n      case 'TaggedTemplateExpression':\n        this.processNode(node.tag);\n        this.processNode(node.quasi);\n        break;\n      case 'TemplateLiteral':\n        node.expressions.forEach(this.processNode.bind(this));\n        break;\n      case 'ThisExpression':\n        this.#addVariable('this', node.start);\n        break;\n      case 'ThrowStatement':\n        this.processNode(node.argument);\n        break;\n      case 'TryStatement':\n        this.processNode(node.block);\n        this.processNode(node.handler ?? null);\n        this.processNode(node.finalizer ?? null);\n        break;\n      case 'WithStatement':\n        this.processNode(node.object);\n        // TODO jarin figure how to treat the with body.\n        this.processNode(node.body);\n        break;\n      case 'YieldExpression':\n        this.processNode(node.argument ?? null);\n        break;\n      case 'UnaryExpression':\n      case 'UpdateExpression':\n        this.processNode(node.argument);\n        break;\n      case 'WhileStatement':\n        this.processNode(node.test);\n        this.processNode(node.body);\n        break;\n\n      // Ignore, no expressions involved.\n      case 'BreakStatement':\n      case 'ContinueStatement':\n      case 'DebuggerStatement':\n      case 'EmptyStatement':\n      case 'Literal':\n      case 'Super':\n      case 'TemplateElement':\n        break;\n        // Ignore, cannot be used outside of a module.\n      case 'ImportDeclaration':\n      case 'ImportDefaultSpecifier':\n      case 'ImportNamespaceSpecifier':\n      case 'ImportSpecifier':\n      case 'ImportExpression':\n      case 'ExportAllDeclaration':\n      case 'ExportDefaultDeclaration':\n      case 'ExportNamedDeclaration':\n      case 'ExportSpecifier':\n        break;\n\n      case 'VariableDeclarator':\n        console.error('Should not encounter VariableDeclarator in general traversal.');\n        break;\n    }\n  }\n\n  getFreeVariables(): Map<string, Use[]> {\n    const result = new Map<string, Use[]>();\n    for (const [name, defUse] of this.#rootScope.variables) {\n      if (defUse.definitionKind !== DefinitionKind.None) {\n        // Skip bound variables.\n        continue;\n      }\n      result.set(name, defUse.uses);\n    }\n    return result;\n  }\n\n  getAllNames(): Set<string> {\n    return this.#allNames;\n  }\n\n  #pushScope(): void {\n    this.#currentScope = new Scope(this.#currentScope);\n  }\n\n  #popScope(isFunctionContext: boolean): void {\n    if (this.#currentScope.parent === null) {\n      console.error('Internal error: wrong nesting in scope analysis.');\n      throw new Error('Internal error');\n    }\n    this.#currentScope.finalizeToParent(isFunctionContext);\n    this.#currentScope = this.#currentScope.parent;\n  }\n\n  #addVariable(\n      name: string, offset: number, definitionKind: DefinitionKind = DefinitionKind.None,\n      isShorthandAssignmentProperty: boolean = false): void {\n    this.#allNames.add(name);\n    this.#currentScope.addVariable(name, offset, definitionKind, isShorthandAssignmentProperty);\n  }\n\n  #processNodeAsDefinition(\n      definitionKind: DefinitionKind.Let|DefinitionKind.Var,\n      node: Acorn.ESTree.Pattern|Acorn.ESTree.AssignmentProperty|null): void {\n    if (node === null) {\n      return;\n    }\n    switch (node.type) {\n      case 'ArrayPattern':\n        node.elements.forEach(this.#processNodeAsDefinition.bind(this, definitionKind));\n        break;\n      case 'AssignmentPattern':\n        this.#processNodeAsDefinition(definitionKind, node.left);\n        this.processNode(node.right);\n        break;\n      case 'Identifier':\n        this.#addVariable(node.name, node.start, definitionKind);\n        break;\n      case 'MemberExpression':\n        this.processNode(node.object);\n        if (node.computed) {\n          this.processNode(node.property);\n        }\n        break;\n      case 'ObjectPattern':\n        node.properties.forEach(this.#processNodeAsDefinition.bind(this, definitionKind));\n        break;\n      case 'Property':\n        // This is AssignmentProperty inside an object pattern.\n        if (node.shorthand) {\n          console.assert(node.value === node.key);\n          console.assert(node.value.type === 'Identifier');\n          this.#addVariable((node.value as Acorn.ESTree.Identifier).name, node.value.start, definitionKind, true);\n        } else {\n          if (node.computed) {\n            this.processNode(node.key);\n          }\n          this.#processNodeAsDefinition(definitionKind, node.value);\n        }\n        break;\n      case 'RestElement':\n        this.#processNodeAsDefinition(definitionKind, node.argument);\n        break;\n    }\n  }\n\n  #processVariableDeclarator(\n      definitionKind: DefinitionKind.Let|DefinitionKind.Var, decl: Acorn.ESTree.VariableDeclarator): void {\n    this.#processNodeAsDefinition(definitionKind, decl.id);\n    this.processNode(decl.init ?? null);\n  }\n}\n"]}