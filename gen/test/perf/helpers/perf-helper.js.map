{"version":3,"file":"perf-helper.js","sourceRoot":"","sources":["../../../../../../test/perf/helpers/perf-helper.ts"],"names":[],"mappings":";AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;;;AAE7B,yBAAyB;AACzB,+BAA0B;AAEnB,MAAM,qBAAqB,GAAG,CAAC,IAAY,EAAE,OAAe,EAAE,EAAE;IACrE,MAAM,SAAS,GAAG,IAAA,WAAI,EAAC,SAAS,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,WAAW,CAAC,CAAC;IACnF,EAAE,CAAC,SAAS,CAAC,SAAS,EAAE,EAAC,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;IAE3C,MAAM,QAAQ,GAAG,IAAA,WAAI,EAAC,SAAS,EAAE,IAAI,CAAC,CAAC;IACvC,EAAE,CAAC,aAAa,CAAC,QAAQ,EAAE,OAAO,EAAE,EAAC,QAAQ,EAAE,MAAM,EAAC,CAAC,CAAC;AAC1D,CAAC,CAAC;AANW,QAAA,qBAAqB,yBAMhC;AAEK,MAAM,UAAU,GAAG,CAAC,MAAgB,EAAE,QAAgB,EAAE,EAAE;IAC/D,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;QACvB,OAAO,CAAC,CAAC;KACV;IAED,MAAM,GAAG,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;IAClD,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,GAAG,QAAQ,CAAC,CAAC;IACjD,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,KAAK,CAAC,EAAE;QAC3B,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC;KACpB;IACD,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;AAC7C,CAAC,CAAC;AAXW,QAAA,UAAU,cAWrB;AAEK,MAAM,IAAI,GAAG,CAAC,MAAgB,EAAE,EAAE;IACvC,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;QACvB,OAAO,CAAC,CAAC;KACV;IACD,OAAO,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,IAAI,EAAE,EAAE,CAAC,IAAI,GAAG,IAAI,EAAE,CAAC,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC;AACvE,CAAC,CAAC;AALW,QAAA,IAAI,QAKf","sourcesContent":["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as fs from 'fs';\nimport {join} from 'path';\n\nexport const storeGeneratedResults = (file: string, content: string) => {\n  const directory = join(__dirname, '..', '..', '..', '..', '..', '..', 'perf-data');\n  fs.mkdirSync(directory, {recursive: true});\n\n  const filePath = join(directory, file);\n  fs.writeFileSync(filePath, content, {encoding: 'utf8'});\n};\n\nexport const percentile = (values: number[], position: number) => {\n  if (values.length === 0) {\n    return 0;\n  }\n\n  values = Array.from(values).sort((a, b) => a - b);\n  const idx = Math.floor(values.length * position);\n  if (values.length % 2 === 1) {\n    return values[idx];\n  }\n  return (values[idx] + values[idx - 1]) / 2;\n};\n\nexport const mean = (values: number[]) => {\n  if (values.length === 0) {\n    return 0;\n  }\n  return values.reduce((prev, curr) => prev + curr, 0) / values.length;\n};\n"]}