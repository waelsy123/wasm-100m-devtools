{"version":3,"file":"pool.js","sourceRoot":"","sources":["../../../../../test/conductor/pool.ts"],"names":[],"mappings":";AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;;;AAM7B,uDAAsD;AACtD,mDAA0C;AAiB1C;;;;;;GAMG;AACH,MAAa,kBAAkB;IACrB,MAAM,CAAU,SAAS,GAAG,CAAC,CAAC;IAEtC,KAAK,GAAG,IAAI,IAAI,EAAsB,CAAC;IACvC,QAAQ,CAAoB;IAC5B,eAAe,CAAS;IAExB,YAAoB,OAA0B,EAAE,cAAsB;QACpE,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,IAAI,CAAC,eAAe,GAAG,cAAc,CAAC;IACxC,CAAC;IAED,oEAAoE;IACpE,MAAM,CAAC,MAAM,CAAC,OAAiC;QAC7C,MAAM,EAAC,OAAO,EAAE,cAAc,EAAE,QAAQ,GAAG,kBAAkB,CAAC,SAAS,EAAC,GAAG,OAAO,CAAC;QAEnF,MAAM,OAAO,GAAG,IAAI,kBAAkB,CAAC,OAAO,EAAE,cAAc,CAAC,CAAC;QAChE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,EAAE,EAAE,CAAC,EAAE;YACjC,KAAK,OAAO,CAAC,gBAAgB,EAAE,CAAC;SACjC;QACD,OAAO,OAAO,CAAC;IACjB,CAAC;IAEO,KAAK,CAAC,gBAAgB;QAC5B,MAAM,MAAM,GAAG,MAAM,yBAAS,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACrD,MAAM,QAAQ,GAAG,MAAM,qCAAmB,CAAC,MAAM,CAC7C,EAAC,OAAO,EAAE,IAAI,CAAC,QAAQ,EAAE,cAAc,EAAE,IAAI,CAAC,eAAe,EAAE,QAAQ,EAAE,MAAM,CAAC,QAAQ,EAAE,EAAC,CAAC,CAAC;QACjG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,EAAC,MAAM,EAAE,QAAQ,EAAC,CAAC,CAAC;IACrC,CAAC;IAED,KAAK,CAAC,WAAW;QACf,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;QAE/B,iEAAiE;QACjE,uEAAuE;QACvE,qBAAqB;QACrB,kEAAkE;QAClE,wEAAwE;QACxE,gEAAgE;QAChE,KAAK,IAAI,CAAC,gBAAgB,EAAE,CAAC;QAE7B,OAAO,IAAI,CAAC;IACd,CAAC;;AA1CH,gDA2CC;AAED;;;;;GAKG;AACH,MAAa,IAAI;IACf,KAAK,GAAQ,EAAE,CAAC;IAChB,MAAM,GAA8B,EAAE,CAAC;IAEvC,GAAG,CAAC,KAAQ;QACV,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;YAC1B,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,EAAwB,CAAC;YACzD,MAAM,CAAC,KAAK,CAAC,CAAC;YACd,OAAO;SACR;QAED,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACzB,CAAC;IAED,IAAI;QACF,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;YACzB,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,EAAO,CAAC;YACtC,OAAO,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;SAC/B;QAED,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE;YAC3B,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QAC5B,CAAC,CAAC,CAAC;IACL,CAAC;CACF;AAxBD,oBAwBC","sourcesContent":["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n// use require here due to\n// https://github.com/evanw/esbuild/issues/587#issuecomment-901397213\nimport puppeteer = require('puppeteer');\n\nimport {DevToolsFrontendTab} from './frontend_tab.js';\nimport {TargetTab} from './target_tab.js';\n\ninterface FrontendTargetTabs {\n  frontend: DevToolsFrontendTab;\n  target: TargetTab;\n}\n\nexport interface FrontedTargetPoolOptions {\n  browser: puppeteer.Browser;\n  testServerPort: number;\n  /**\n   * Defaults to FrontendTargetPool.POOL_SIZE.\n   * Setting `poolSize` to 0 will create target/frontend pairs on-demand.\n   */\n  poolSize?: number;\n}\n\n/**\n * A pool of DevTools frontend tab plus target tab pairs. Every time a pair\n * is taken from the pool, the pool will automatically prepare another pair.\n *\n * Tab pairs are not intended to be reused and its the consumer's responsibility\n * to clean them up properly.\n */\nexport class FrontendTargetPool {\n  private static readonly POOL_SIZE = 5;\n\n  #pool = new Pool<FrontendTargetTabs>();\n  #browser: puppeteer.Browser;\n  #testServerPort: number;\n\n  private constructor(browser: puppeteer.Browser, testServerPort: number) {\n    this.#browser = browser;\n    this.#testServerPort = testServerPort;\n  }\n\n  /** Returns a pool with `options.poolSize` tab pairs ready to go. */\n  static create(options: FrontedTargetPoolOptions): FrontendTargetPool {\n    const {browser, testServerPort, poolSize = FrontendTargetPool.POOL_SIZE} = options;\n\n    const tabPool = new FrontendTargetPool(browser, testServerPort);\n    for (let i = 0; i < poolSize; ++i) {\n      void tabPool.addTabPairToPool();\n    }\n    return tabPool;\n  }\n\n  private async addTabPairToPool(): Promise<void> {\n    const target = await TargetTab.create(this.#browser);\n    const frontend = await DevToolsFrontendTab.create(\n        {browser: this.#browser, testServerPort: this.#testServerPort, targetId: target.targetId()});\n    this.#pool.put({target, frontend});\n  }\n\n  async takeTabPair(): Promise<FrontendTargetTabs> {\n    const pair = this.#pool.take();\n\n    // We took a pair, so lets queue up the creation of a fresh pair.\n    // It's important that we do not block here, the fresh pair is prepared\n    // in the background.\n    // Also note that this approach allows a pool size of 0. For every\n    // `takeTabPair`, we call `addTabPairToPool`. The resulting pair is then\n    // used to resolve the `pair` promise of the `takeTabPair` call.\n    void this.addTabPairToPool();\n\n    return pair;\n  }\n}\n\n/**\n * A simple Promise-based pool. Esentially a queue.\n *\n * When the pool is empty, consumers get a promise that resolves as soon as\n * the pool is refilled.\n */\nexport class Pool<T> {\n  #pool: T[] = [];\n  #queue: Array<(value: T) => void> = [];\n\n  put(value: T) {\n    if (this.#queue.length > 0) {\n      const waitee = this.#queue.shift() as (value: T) => void;\n      waitee(value);\n      return;\n    }\n\n    this.#pool.push(value);\n  }\n\n  take(): Promise<T> {\n    if (this.#pool.length > 0) {\n      const value = this.#pool.shift() as T;\n      return Promise.resolve(value);\n    }\n\n    return new Promise(resolve => {\n      this.#queue.push(resolve);\n    });\n  }\n}\n"]}