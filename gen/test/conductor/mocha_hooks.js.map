{"version":3,"file":"mocha_hooks.js","sourceRoot":"","sources":["../../../../../test/conductor/mocha_hooks.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as fs from 'fs';\nimport {createCoverageMap, createFileCoverage} from 'istanbul-lib-coverage';\nimport * as report from 'istanbul-lib-report';\nimport {createSourceMapStore} from 'istanbul-lib-source-maps';\nimport * as reports from 'istanbul-reports';\nimport * as path from 'path';\nimport * as rimraf from 'rimraf';\n\nimport {collectCoverageFromPage, postFileTeardown, preFileSetup, resetPages} from './hooks.js';\nimport {getTestRunnerConfigSetting} from './test_runner_config.js';\nimport {startServer, stopServer} from './test_server.js';\n\n/* eslint-disable no-console */\n\nprocess.on('SIGINT', postFileTeardown);\n\nconst TEST_SERVER_TYPE = getTestRunnerConfigSetting<string>('test-server-type', 'hosted-mode');\n\nif (TEST_SERVER_TYPE !== 'hosted-mode' && TEST_SERVER_TYPE !== 'component-docs' && TEST_SERVER_TYPE !== 'none') {\n  throw new Error(`Invalid test server type: ${TEST_SERVER_TYPE}`);\n}\n\n// Required to reassign to allow for TypeScript to correctly deduce its type\nconst DERIVED_SERVER_TYPE = TEST_SERVER_TYPE;\n\n// We can run Mocha in two modes: serial and parallel. In parallel mode, Mocha\n// starts multiple node processes which don't know about each other. It provides\n// them one test file at a time, and when they are finished with that file they\n// ask for another one. This means in parallel mode, the unit of work is a test\n// file, and a full setup and teardown is done before/after each file even if it\n// will eventually run another test file. This is inefficient for us because we\n// have a relatively long setup time, but we can't avoid it at the moment. It\n// also means that the setup and teardown code needs to be aware that it may be\n// run multiple times within the same node process.\n\n// The two functions below are 'global setup fixtures':\n// https://mochajs.org/#global-setup-fixtures. These let us start one hosted\n// mode server and share it between all the parallel test runners.\nexport async function mochaGlobalSetup(this: Mocha.Suite) {\n  // Start the test server in the 'main' process. In parallel mode, we\n  // share one server between all parallel runners. The parallel runners are all\n  // in different processes, so we pass the port number as an environment var.\n  if (DERIVED_SERVER_TYPE === 'none') {\n    return;\n  }\n  process.env.testServerPort = String(await startServer(DERIVED_SERVER_TYPE));\n  console.log(`Started ${DERIVED_SERVER_TYPE} server on port ${process.env.testServerPort}`);\n}\n\nexport function mochaGlobalTeardown() {\n  console.log('Stopping server');\n  stopServer();\n}\n\nconst testSuiteCoverageMap = createCoverageMap();\nconst SHOULD_GATHER_COVERAGE_INFORMATION = process.env.COVERAGE === '1' && DERIVED_SERVER_TYPE === 'component-docs';\nconst INTERACTIONS_COVERAGE_LOCATION = path.join(process.cwd(), 'interactions-coverage/');\n\n// These are the 'root hook plugins': https://mochajs.org/#root-hook-plugins\n// These open and configure the browser before tests are run.\nexport const mochaHooks = {\n  // In serial mode (Mochaâ€™s default), before all tests begin, once only.\n  // In parallel mode, run before all tests begin, for each file.\n  beforeAll: async function(this: Mocha.Suite) {\n    // It can take arbitrarly long on bots to boot up a server and start\n    // DevTools. Since this timeout only applies for this hook, we can let it\n    // take an arbitrarily long time, while still enforcing that tests run\n    // reasonably quickly (2 seconds by default).\n    this.timeout(0);\n    await preFileSetup(Number(process.env.testServerPort));\n\n    // Pause when running interactively in debug mode. This is mututally\n    // exclusive with parallel mode.\n    if (process.env['DEBUG_TEST']) {\n      console.log('Running in debug mode.');\n      console.log(' - Press enter to run the test suite.');\n      console.log(' - Press ctrl + c to quit.');\n\n      await new Promise<void>(resolve => {\n        const {stdin} = process;\n\n        stdin.on('data', () => {\n          stdin.pause();\n          resolve();\n        });\n      });\n    }\n  },\n  // In serial mode, run after all tests end, once only.\n  // In parallel mode, run after all tests end, for each file.\n  afterAll: async function(this: Mocha.Suite) {\n    await postFileTeardown();\n\n    if (!SHOULD_GATHER_COVERAGE_INFORMATION) {\n      return;\n    }\n\n    // Writing the coverage files to disk can take a lot longer on CQ than the\n    // default timeout. Since all of this work is synchronous (and would\n    // immediately fail if it went wrong), we can set the timeout to infinite\n    // here.\n    this.timeout(0);\n\n    // Make sure that any previously existing coverage reports are purged.\n    if (fs.existsSync(INTERACTIONS_COVERAGE_LOCATION)) {\n      rimraf.sync(INTERACTIONS_COVERAGE_LOCATION);\n    }\n\n    const remappedCoverageMap = await createSourceMapStore().transformCoverage(testSuiteCoverageMap);\n    const context = report.createContext({\n      dir: INTERACTIONS_COVERAGE_LOCATION,\n      coverageMap: remappedCoverageMap,\n      defaultSummarizer: 'nested',\n    });\n    reports.create('html').execute(context);\n    reports.create('json').execute(context);\n    reports.create('json-summary').execute(context);\n  },\n  // In both modes, run before each test.\n  beforeEach: async function(this: Mocha.Suite) {\n    // Sets the timeout higher for this hook only.\n    this.timeout(10000);\n    await resetPages();\n  },\n  afterEach: async function(this: Mocha.Suite) {\n    if (!SHOULD_GATHER_COVERAGE_INFORMATION) {\n      return;\n    }\n\n    const coverageData = await collectCoverageFromPage();\n    const testCoverageMap = createCoverageMap();\n\n    if (coverageData) {\n      for (const file of Object.values(coverageData)) {\n        testCoverageMap.addFileCoverage(createFileCoverage(file));\n      }\n    }\n\n    testSuiteCoverageMap.merge(testCoverageMap);\n  },\n};\n"]}