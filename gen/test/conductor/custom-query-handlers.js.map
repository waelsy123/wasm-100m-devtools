{"version":3,"file":"custom-query-handlers.js","sourceRoot":"","sources":["../../../../../test/conductor/custom-query-handlers.ts"],"names":[],"mappings":";AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;;;AAE7B;;;;;;;EAOE;AAEK,MAAM,0BAA0B,GAAG,CACtC,OAAoC,EACpC,IAAY,EACI,EAAE;IACpB,IAAI,KAAK,GAAiB,IAAI,CAAC;IAC/B,MAAM,MAAM,GAAG,CAAC,IAAwB,EAAE,EAAE;QAC1C,MAAM,IAAI,GAAG,QAAQ,CAAC,gBAAgB,CAClC,IAAI,EACJ,UAAU,CAAC,YAAY,CAC1B,CAAC;QACF,GAAG;YACD,MAAM,WAAW,GAAG,IAAI,CAAC,WAA0B,CAAC;YACpD,IAAI,WAAW,CAAC,UAAU,EAAE;gBAC1B,MAAM,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;aAChC;YACD,IAAI,WAAW,YAAY,UAAU,EAAE;gBACrC,SAAS;aACV;YACD,IAAI,CAAC,KAAK,IAAI,WAAW,CAAC,WAAW,KAAK,IAAI,EAAE;gBAC9C,KAAK,GAAG,WAAW,CAAC;aACrB;SACF,QAAQ,CAAC,KAAK,IAAI,IAAI,CAAC,QAAQ,EAAE,EAAE;IACtC,CAAC,CAAC;IACF,IAAI,OAAO,YAAY,QAAQ,EAAE;QAC/B,OAAO,GAAG,OAAO,CAAC,eAAe,CAAC;KACnC;IACD,MAAM,CAAC,OAAO,CAAC,CAAC;IAChB,OAAO,KAAK,CAAC;AACf,CAAC,CAAC;AA5BW,QAAA,0BAA0B,8BA4BrC;AAEK,MAAM,0BAA0B,GAAG,CACtC,OAAyB,EACzB,QAAgB,EACH,EAAE;IACjB,MAAM,MAAM,GAAc,EAAE,CAAC;IAC7B,MAAM,OAAO,GAAG,CAAC,IAAwB,EAAE,EAAE;QAC3C,MAAM,IAAI,GAAG,QAAQ,CAAC,gBAAgB,CAClC,IAAI,EACJ,UAAU,CAAC,YAAY,CAC1B,CAAC;QACF,GAAG;YACD,MAAM,WAAW,GAAG,IAAI,CAAC,WAA0B,CAAC;YACpD,IAAI,WAAW,CAAC,UAAU,EAAE;gBAC1B,OAAO,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;aACjC;YACD,IAAI,WAAW,YAAY,UAAU,EAAE;gBACrC,SAAS;aACV;YACD,IAAI,WAAW,CAAC,WAAW,KAAK,QAAQ,EAAE;gBACxC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;aAC1B;SACF,QAAQ,IAAI,CAAC,QAAQ,EAAE,EAAE;IAC5B,CAAC,CAAC;IACF,IAAI,OAAO,YAAY,QAAQ,EAAE;QAC/B,OAAO,GAAG,OAAO,CAAC,eAAe,CAAC;KACnC;IACD,OAAO,CAAC,OAAO,CAAC,CAAC;IACjB,OAAO,MAAM,CAAC;AAChB,CAAC,CAAC;AA5BW,QAAA,0BAA0B,8BA4BrC","sourcesContent":["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n* The following custom query all implement the same traversal logic and as such\n* it would be nice if we could refactor this out instead of repeating ourselves.\n* But because the handlers will be stringified and sent over the wire through\n* CDP, we need the functions to be completely self-contained and not refer any\n* names from the outer scope. This means that such a refactoring can only be\n* achieved by using reflection, which we decided against.\n*/\n\nexport const querySelectorShadowTextOne = (\n    element: Element|Document|ShadowRoot,\n    text: string,\n    ): Element|null => {\n  let found: Element|null = null;\n  const search = (root: Element|ShadowRoot) => {\n    const iter = document.createTreeWalker(\n        root,\n        NodeFilter.SHOW_ELEMENT,\n    );\n    do {\n      const currentNode = iter.currentNode as HTMLElement;\n      if (currentNode.shadowRoot) {\n        search(currentNode.shadowRoot);\n      }\n      if (currentNode instanceof ShadowRoot) {\n        continue;\n      }\n      if (!found && currentNode.textContent === text) {\n        found = currentNode;\n      }\n    } while (!found && iter.nextNode());\n  };\n  if (element instanceof Document) {\n    element = element.documentElement;\n  }\n  search(element);\n  return found;\n};\n\nexport const querySelectorShadowTextAll = (\n    element: Element|Document,\n    selector: string,\n    ): Element[] => {\n  const result: Element[] = [];\n  const collect = (root: Element|ShadowRoot) => {\n    const iter = document.createTreeWalker(\n        root,\n        NodeFilter.SHOW_ELEMENT,\n    );\n    do {\n      const currentNode = iter.currentNode as HTMLElement;\n      if (currentNode.shadowRoot) {\n        collect(currentNode.shadowRoot);\n      }\n      if (currentNode instanceof ShadowRoot) {\n        continue;\n      }\n      if (currentNode.textContent === selector) {\n        result.push(currentNode);\n      }\n    } while (iter.nextNode());\n  };\n  if (element instanceof Document) {\n    element = element.documentElement;\n  }\n  collect(element);\n  return result;\n};\n"]}