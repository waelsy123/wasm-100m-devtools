{"version":3,"file":"async-scope.js","sourceRoot":"","sources":["../../../../../test/shared/async-scope.ts"],"names":[],"mappings":";AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;;;AAE7B,MAAa,UAAU;IACrB,MAAM,CAAC,MAAM,GAAoB,IAAI,GAAG,EAAE,CAAC;IACnC,UAAU,GAAe,EAAE,CAAC;IAC5B,QAAQ,GAAY,KAAK,CAAC;IAElC,WAAW;QACT,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;IACvB,CAAC;IAED,UAAU;QACR,OAAO,IAAI,CAAC,QAAQ,CAAC;IACvB,CAAC;IAED,IAAI,KAAK;QACP,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,KAAK,CAAC,EAAE;YAChC,OAAO,IAAI,CAAC;SACb;QACD,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IACrD,CAAC;IAED,IAAI;QACF,MAAM,KAAK,GAAG,IAAI,KAAK,EAAE,CAAC,KAAK,CAAC;QAChC,IAAI,CAAC,KAAK,EAAE;YACV,MAAM,IAAI,KAAK,CAAC,2BAA2B,CAAC,CAAC;SAC9C;QAED,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,KAAK,CAAC,EAAE;YAChC,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;SAC7B;QACD,MAAM,aAAa,GAAG,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,MAAM,CAC1C,KAAK,CAAC,EAAE,CACJ,CAAC,CAAC,KAAK,KAAK,OAAO,IAAI,KAAK,CAAC,QAAQ,CAAC,YAAY,CAAC,IAAI,KAAK,CAAC,QAAQ,CAAC,eAAe,CAAC;YACpF,KAAK,CAAC,QAAQ,CAAC,2BAA2B,CAAC,CAAC,CAAC,CAAC;QACxD,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;IACtC,CAAC;IAED,GAAG;QACD,IAAI,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC;QACtB,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,KAAK,CAAC,EAAE;YAChC,UAAU,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;SAChC;IACH,CAAC;IAED,KAAK,CAAC,IAAI,CAAI,QAA0B;QACtC,IAAI,CAAC,IAAI,EAAE,CAAC;QACZ,IAAI;YACF,MAAM,MAAM,GAAG,MAAM,QAAQ,EAAE,CAAC;YAChC,OAAO,MAAM,CAAC;SACf;gBAAS;YACR,IAAI,CAAC,GAAG,EAAE,CAAC;SACZ;IACH,CAAC;IAED,QAAQ,CAAI,QAAiB;QAC3B,IAAI,CAAC,IAAI,EAAE,CAAC;QACZ,IAAI;YACF,MAAM,MAAM,GAAG,QAAQ,EAAE,CAAC;YAC1B,OAAO,MAAM,CAAC;SACf;gBAAS;YACR,IAAI,CAAC,GAAG,EAAE,CAAC;SACZ;IACH,CAAC;;AA7DH,gCA8DC","sourcesContent":["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport class AsyncScope {\n  static scopes: Set<AsyncScope> = new Set();\n  private asyncStack: string[][] = [];\n  private canceled: boolean = false;\n\n  setCanceled(): void {\n    this.canceled = true;\n  }\n\n  isCanceled(): boolean {\n    return this.canceled;\n  }\n\n  get stack() {\n    if (this.asyncStack.length === 0) {\n      return null;\n    }\n    return this.asyncStack[this.asyncStack.length - 1];\n  }\n\n  push() {\n    const stack = new Error().stack;\n    if (!stack) {\n      throw new Error('Could not get stack trace');\n    }\n\n    if (this.asyncStack.length === 0) {\n      AsyncScope.scopes.add(this);\n    }\n    const filteredStack = stack.split('\\n').filter(\n        value =>\n            !(value === 'Error' || value.includes('AsyncScope') || value.includes('runMicrotasks') ||\n              value.includes('processTicksAndRejections')));\n    this.asyncStack.push(filteredStack);\n  }\n\n  pop() {\n    this.asyncStack.pop();\n    if (this.asyncStack.length === 0) {\n      AsyncScope.scopes.delete(this);\n    }\n  }\n\n  async exec<T>(callable: () => Promise<T>) {\n    this.push();\n    try {\n      const result = await callable();\n      return result;\n    } finally {\n      this.pop();\n    }\n  }\n\n  execSync<T>(callable: () => T) {\n    this.push();\n    try {\n      const result = callable();\n      return result;\n    } finally {\n      this.pop();\n    }\n  }\n}\n"]}