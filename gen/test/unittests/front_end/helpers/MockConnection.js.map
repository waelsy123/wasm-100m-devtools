{"version":3,"file":"MockConnection.js","sourceRoot":"","sources":["../../../../../../../test/unittests/front_end/helpers/MockConnection.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as ProtocolClient from '../../../../front_end/core/protocol_client/protocol_client.js';\nimport type {ProtocolMapping} from '../../../../front_end/generated/protocol-mapping.js'; // eslint-disable-line rulesdir/es_modules_import\nimport type * as ProtocolProxyApi from '../../../../front_end/generated/protocol-proxy-api.js';\n\nimport {deinitializeGlobalVars, initializeGlobalVars} from './EnvironmentHelpers.js';\n\nimport type * as SDK from '../../../../front_end/core/sdk/sdk.js';\n\nexport type ProtocolCommand = keyof ProtocolMapping.Commands;\nexport type ProtocolCommandParams<C extends ProtocolCommand> = ProtocolMapping.Commands[C]['paramsType'];\nexport type ProtocolResponse<C extends ProtocolCommand> = ProtocolMapping.Commands[C]['returnType'];\nexport type ProtocolCommandHandler<C extends ProtocolCommand> = (...params: ProtocolCommandParams<C>) =>\n    Omit<ProtocolResponse<C>, 'getError'>;\nexport type MessageCallback = (result: string|Object) => void;\n\n// Note that we can't set the Function to the correct handler on the basis\n// that we don't know which ProtocolCommand will be stored.\nconst responseMap = new Map<ProtocolCommand, Function>();\nexport function setMockConnectionResponseHandler<C extends ProtocolCommand>(\n    command: C, handler: ProtocolCommandHandler<C>) {\n  if (responseMap.get(command)) {\n    throw new Error(`Response handler already set for ${command}`);\n  }\n\n  responseMap.set(command, handler);\n}\n\nexport function getMockConnectionResponseHandler(method: ProtocolCommand) {\n  return responseMap.get(method);\n}\n\nexport function clearMockConnectionResponseHandler(method: ProtocolCommand) {\n  responseMap.delete(method);\n}\n\nexport function clearAllMockConnectionResponseHandlers() {\n  responseMap.clear();\n}\n\nexport function dispatchEvent<E extends keyof ProtocolMapping.Events>(\n    target: SDK.Target.Target, eventName: E, ...payload: ProtocolMapping.Events[E]) {\n  const event = eventName as ProtocolClient.InspectorBackend.QualifiedName;\n  const [domain] = ProtocolClient.InspectorBackend.splitQualifiedName(event);\n\n  const registeredEvents =\n      ProtocolClient.InspectorBackend.inspectorBackend.getOrCreateEventParameterNamesForDomainForTesting(\n          domain as keyof ProtocolProxyApi.ProtocolDispatchers);\n  const eventParameterNames = registeredEvents.get(event);\n  if (!eventParameterNames) {\n    // The event is not registered, fake-register with empty parameters.\n    registeredEvents.set(event, []);\n  }\n\n  target.dispatch({method: event, params: payload[0]});\n}\n\nasync function enable({reset = true} = {}) {\n  if (reset) {\n    responseMap.clear();\n  }\n\n  // The DevTools frontend code expects certain things to be in place\n  // before it can run. This function will ensure those things are\n  // minimally there.\n  await initializeGlobalVars({reset});\n\n  let messageCallback: MessageCallback;\n  ProtocolClient.InspectorBackend.Connection.setFactory(() => {\n    return {\n      setOnMessage(callback: MessageCallback) {\n        messageCallback = callback;\n      },\n\n      sendRawMessage(message: string) {\n        const outgoingMessage = JSON.parse(message) as {id: number, method: ProtocolCommand, params: unknown};\n        const handler = responseMap.get(outgoingMessage.method);\n        if (!handler) {\n          return;\n        }\n\n        const result = handler.call(undefined, outgoingMessage.params);\n\n        // Since we allow the test author to omit the getError call, we\n        // need to add it in here on their behalf so that the calling code\n        // will succeed.\n        if (!('getError' in result)) {\n          result.getError = () => undefined;\n        }\n        messageCallback.call(undefined, {id: outgoingMessage.id, method: outgoingMessage.method, result});\n      },\n\n      async disconnect() {\n        // Included only to meet interface requirements.\n      },\n\n      onMessage() {\n        // Included only to meet interface requirements.\n      },\n\n      setOnDisconnect() {\n        // Included only to meet interface requirements.\n      },\n    };\n  });\n}\n\nasync function disable() {\n  await deinitializeGlobalVars();\n  // @ts-ignore Setting back to undefined as a hard reset.\n  ProtocolClient.InspectorBackend.Connection.setFactory(undefined);\n}\n\nexport function describeWithMockConnection(title: string, fn: (this: Mocha.Suite) => void, opts: {reset: boolean} = {\n  reset: true,\n}) {\n  return describe(`mock-${title}`, () => {\n    beforeEach(async () => await enable(opts));\n    afterEach(disable);\n    describe(title, fn);\n  });\n}\n"]}