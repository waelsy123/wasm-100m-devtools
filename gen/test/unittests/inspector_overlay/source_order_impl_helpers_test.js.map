{"version":3,"file":"source_order_impl_helpers_test.js","sourceRoot":"","sources":["../../../../../../test/unittests/inspector_overlay/source_order_impl_helpers_test.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nconst {assert} = chai;\n\nimport {getPositionFromLabelType, getLabelType, LabelTypes} from '../../../inspector_overlay/tool_source_order.js';\n\nconst positionTypes = Object.values(LabelTypes);\nconst labelHeight = 22;\nconst labelWidth = 27;\nconst defaultBounds = {\n  minX: 100,\n  minY: 100,\n  maxX: 200,\n  maxY: 200,\n};\n\ndescribe('getPositionFromLabelType', () => {\n  type PositionId = 'to'|'ab'|'be'|'bo';\n  const expectedPositions = {\n    'to': defaultBounds.minY,\n    'ab': defaultBounds.minY - labelHeight,\n    'be': defaultBounds.maxY,\n    'bo': defaultBounds.maxY - labelHeight,\n  };\n\n  for (const positionType of positionTypes) {\n    it('can place ' + positionType, () => {\n      const position = getPositionFromLabelType(positionType, defaultBounds, labelHeight);\n      const positionId = positionType.slice(0, 2);\n\n      assert.strictEqual(\n          position.contentTop, expectedPositions[<PositionId>positionId], 'incorrect offset from the top of the page');\n      assert.strictEqual(position.contentLeft, defaultBounds.minX, 'incorrect offset from the left of the page');\n    });\n  }\n});\n\ndescribe('getLabelType', () => {\n  const thinBounds = {minX: 100, minY: 100, maxX: 110, maxY: 200};\n  const shortBounds = {minX: 100, minY: 100, maxX: 200, maxY: 110};\n  const canvasHeight = 1000;\n\n  const TESTS = [\n    {\n      description: 'can assign topCorner type when the associated element is large enough',\n      bounds: defaultBounds,\n      overlap: false,\n      expectedType: LabelTypes.topCorner,\n    },\n    {\n      description: 'can assign aboveElementWider type when the label is wider than the associated element',\n      bounds: thinBounds,\n      overlap: false,\n      expectedType: LabelTypes.aboveElementWider,\n    },\n    {\n      description: 'can assign aboveElement type when the label is taller than the associated element',\n      bounds: shortBounds,\n      overlap: false,\n      expectedType: LabelTypes.aboveElement,\n    },\n    {\n      description:\n          'can assign belowElementWider type when a label in the above-element postition would extend off the page and the label is wider than the associated element',\n      bounds: {minX: 100, minY: 0, maxX: 110, maxY: 200},\n      overlap: false,\n      expectedType: LabelTypes.belowElementWider,\n    },\n    {\n      description:\n          'can assign below-element type when a label in the above-element postition would overlap with another label and the label is wider than the associated element',\n      bounds: thinBounds,\n      overlap: true,\n      expectedType: LabelTypes.belowElementWider,\n    },\n    {\n      description: 'can assign belowElement type when a label in the above-element postition would extend off the page',\n      bounds: {minX: 100, minY: 0, maxX: 200, maxY: 10},\n      overlap: false,\n      expectedType: LabelTypes.belowElement,\n    },\n    {\n      description:\n          'can assign below-element type when a label in the above-element postition would overlap with another label',\n      bounds: shortBounds,\n      overlap: true,\n      expectedType: LabelTypes.belowElement,\n    },\n    {\n      description:\n          'can assign bottomCornerWider type when a label in the below-element position would extend off the page and the label is wider than the associated element',\n      bounds: {minX: 100, minY: canvasHeight - 100, maxX: 110, maxY: canvasHeight},\n      overlap: true,\n      expectedType: LabelTypes.bottomCornerWider,\n    },\n    {\n      description:\n          'can assign bottomCornerTaller type when a label in the below-element position would extend off the page and the label is taller than the associated element',\n      bounds: {minX: 100, minY: canvasHeight - 10, maxX: 200, maxY: canvasHeight},\n      overlap: true,\n      expectedType: LabelTypes.bottomCornerTaller,\n    },\n    {\n      description:\n          'can assign bottomCornerWiderTaller type when a label in the below-element position would extend off the page and the label is both wider and taller than the associated element',\n      bounds: {minX: 100, minY: canvasHeight - 10, maxX: 110, maxY: canvasHeight},\n      overlap: true,\n      expectedType: LabelTypes.bottomCornerWiderTaller,\n    },\n  ];\n\n  for (const {description, bounds, overlap, expectedType} of TESTS) {\n    it(description, () => {\n      const otherLabelsCollection = <HTMLCollectionOf<HTMLElement>><unknown>[];\n      if (overlap) {\n        const y = bounds.minY - labelHeight;\n        const overlappingLabel = <HTMLElement><unknown>{\n          getBoundingClientRect: () => {\n            return new DOMRect(bounds.minX, y, labelWidth, labelHeight);\n          },\n          style: {top: bounds.minX + 'px', left: y + 'px'},\n        };\n        otherLabelsCollection[0] = overlappingLabel;\n      }\n\n      const positionType = getLabelType(bounds, labelHeight, labelWidth, otherLabelsCollection, canvasHeight);\n      assert.strictEqual(positionType, expectedType, 'incorrect position type');\n    });\n  }\n});\n"]}