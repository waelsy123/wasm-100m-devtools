{"version":3,"file":"css_grid_label_helpers.js","sourceRoot":"","sources":["../../../../inspector_overlay/css_grid_label_helpers.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport {luminance} from '../front_end/core/common/ColorUtils.js';  // eslint-disable-line rulesdir/es_modules_import\n\nimport type {AreaBounds, Bounds, Position} from './common.js';\nimport {createChild} from './common.js';\nimport {applyMatrixToPoint, parseHexa} from './highlight_common.js';\n\n/**\n * There are 12 different types of arrows for labels.\n *\n * The first word in an arrow type corresponds to the side of the label\n * container the arrow is on (e.g. 'left' means the arrow is on the left side of\n * the container).\n *\n * The second word defines where, along that side, the arrow is (e.g. 'top' in\n * a 'leftTop' type means the arrow is at the top of the left side of the\n * container).\n *\n * Here are 2 examples to illustrate:\n *\n *              +----+\n * rightMid:    |     >\n *              +----+\n *\n *              +----+\n * bottomRight: |    |\n *              +--  +\n *                  \\|\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst GridArrowTypes = {\n  leftTop: 'left-top',\n  leftMid: 'left-mid',\n  leftBottom: 'left-bottom',\n  topLeft: 'top-left',\n  topMid: 'top-mid',\n  topRight: 'top-right',\n  rightTop: 'right-top',\n  rightMid: 'right-mid',\n  rightBottom: 'right-bottom',\n  bottomLeft: 'bottom-left',\n  bottomMid: 'bottom-mid',\n  bottomRight: 'bottom-right',\n};\n\n// The size (in px) of a label arrow.\nconst gridArrowWidth = 3;\n// The minimum distance (in px) a label has to be from the edge of the viewport\n// to avoid being flipped inside the grid.\nconst gridPageMargin = 20;\n// The minimum distance (in px) 2 labels can be to eachother. This is set to\n// allow 2 consecutive 2-digits labels to not overlap.\nconst gridLabelDistance = 20;\n// The maximum number of custom line names that can be displayed in a label.\nconst maxLineNamesCount = 3;\nconst defaultLabelColor = '#1A73E8';\nconst defaultLabelTextColor = '#121212';\n\nexport interface CanvasSize {\n  canvasWidth: number;\n  canvasHeight: number;\n}\n\ninterface PositionData {\n  positions: Position[];\n  hasFirst: boolean;\n  hasLast: boolean;\n  names?: string[][];\n}\n\ntype PositionDataWithNames = PositionData&{\n  names: string[][],\n};\n\ninterface TracksPositionData {\n  positive: PositionData;\n  negative: PositionData;\n}\n\ninterface TracksPositionDataWithNames {\n  positive: PositionDataWithNames;\n  negative: PositionDataWithNames;\n}\n\ninterface GridPositionNormalizedData {\n  rows: TracksPositionData;\n  columns: TracksPositionData;\n  bounds: Bounds;\n}\n\nexport interface GridPositionNormalizedDataWithNames {\n  rows: TracksPositionDataWithNames;\n  columns: TracksPositionDataWithNames;\n  bounds: Bounds;\n}\n\ninterface TrackSize {\n  computedSize: number;\n  authoredSize?: number;\n  x: number;\n  y: number;\n}\n\nexport interface GridHighlightOptions {\n  gridBorderDash: boolean;\n  rowLineDash: boolean;\n  columnLineDash: boolean;\n  showGridExtensionLines: boolean;\n  showPositiveLineNumbers: boolean;\n  showNegativeLineNumbers: boolean;\n  rowLineColor?: string;\n  columnLineColor?: string;\n  rowHatchColor: string;\n  columnHatchColor: string;\n  showLineNames: boolean;\n}\n\nexport interface GridHighlightConfig {\n  rotationAngle?: number;\n  writingMode?: string;\n  columnTrackSizes?: TrackSize[];\n  rowTrackSizes?: TrackSize[];\n  positiveRowLineNumberPositions?: Position[];\n  negativeRowLineNumberPositions?: Position[];\n  positiveColumnLineNumberPositions?: Position[];\n  negativeColumnLineNumberPositions?: Position[];\n  rowLineNameOffsets?: {name: string, x: number, y: number}[];\n  columnLineNameOffsets?: {name: string, x: number, y: number}[];\n  gridHighlightConfig?: GridHighlightOptions;\n}\n\ninterface LabelSize {\n  width: number;\n  height: number;\n  mainSize: number;\n  crossSize: number;\n}\n\nexport interface GridLabelState {\n  gridLayerCounter: number;\n}\n\n/**\n * Places all of the required grid labels on the overlay. This includes row and\n * column line number labels, and area labels.\n */\nexport function drawGridLabels(\n    config: GridHighlightConfig, gridBounds: Bounds, areaBounds: AreaBounds[], canvasSize: CanvasSize,\n    labelState: GridLabelState, emulationScaleFactor: number,\n    writingModeMatrix: DOMMatrix|undefined = new DOMMatrix()) {\n  // Find and clear the layer for the node specified in the config, or the default layer:\n  // Each node has a layer for grid labels in order to draw multiple grid highlights\n  // at once.\n  const labelContainerId = `grid-${labelState.gridLayerCounter++}-labels`;\n  let labelContainerForNode = document.getElementById(labelContainerId);\n  if (!labelContainerForNode) {\n    const mainLabelLayerContainer = document.getElementById('grid-label-container');\n    if (!mainLabelLayerContainer) {\n      throw new Error('#grid-label-container is not found');\n    }\n    labelContainerForNode = createChild(mainLabelLayerContainer, 'div');\n    labelContainerForNode.id = labelContainerId;\n  }\n\n  const rowColor = config.gridHighlightConfig && config.gridHighlightConfig.rowLineColor ?\n      config.gridHighlightConfig.rowLineColor :\n      defaultLabelColor;\n  const rowTextColor = generateLegibleTextColor(rowColor);\n\n  labelContainerForNode.style.setProperty('--row-label-color', rowColor);\n  labelContainerForNode.style.setProperty('--row-label-text-color', rowTextColor);\n\n  const columnColor = config.gridHighlightConfig && config.gridHighlightConfig.columnLineColor ?\n      config.gridHighlightConfig.columnLineColor :\n      defaultLabelColor;\n  const columnTextColor = generateLegibleTextColor(columnColor);\n\n  labelContainerForNode.style.setProperty('--column-label-color', columnColor);\n  labelContainerForNode.style.setProperty('--column-label-text-color', columnTextColor);\n\n  labelContainerForNode.innerText = '';\n\n  // Add the containers for the line and area to the node's layer\n  const areaNameContainer = createChild(labelContainerForNode, 'div', 'area-names');\n  const lineNameContainer = createChild(labelContainerForNode, 'div', 'line-names');\n  const lineNumberContainer = createChild(labelContainerForNode, 'div', 'line-numbers');\n  const trackSizesContainer = createChild(labelContainerForNode, 'div', 'track-sizes');\n\n  // Draw line numbers and names.\n  const normalizedData = normalizePositionData(config, gridBounds);\n  if (config.gridHighlightConfig && config.gridHighlightConfig.showLineNames) {\n    drawGridLineNames(\n        lineNameContainer, normalizedData as GridPositionNormalizedDataWithNames, canvasSize, emulationScaleFactor,\n        writingModeMatrix, config.writingMode);\n  } else {\n    drawGridLineNumbers(\n        lineNumberContainer, normalizedData, canvasSize, emulationScaleFactor, writingModeMatrix, config.writingMode);\n  }\n\n  // Draw area names.\n  drawGridAreaNames(areaNameContainer, areaBounds, writingModeMatrix, config.writingMode);\n\n  if (config.columnTrackSizes) {\n    // Draw column sizes.\n    drawGridTrackSizes(\n        trackSizesContainer, config.columnTrackSizes, 'column', canvasSize, emulationScaleFactor, writingModeMatrix,\n        config.writingMode);\n  }\n  if (config.rowTrackSizes) {\n    // Draw row sizes.\n    drawGridTrackSizes(\n        trackSizesContainer, config.rowTrackSizes, 'row', canvasSize, emulationScaleFactor, writingModeMatrix,\n        config.writingMode);\n  }\n}\n\n/**\n * This is a generator function used to iterate over grid label positions in a way\n * that skips the ones that are too close to eachother, in order to avoid overlaps.\n */\nfunction* positionIterator(positions: Position[], axis: 'x'|'y'): Generator<[number, Position]> {\n  let lastEmittedPos = null;\n\n  for (const [i, pos] of positions.entries()) {\n    // Only emit the position if this is the first.\n    const isFirst = i === 0;\n    // Or if this is the last.\n    const isLast = i === positions.length - 1;\n    // Or if there is some minimum distance between the last emitted position.\n    const isFarEnoughFromPrevious =\n        Math.abs(pos[axis] - (lastEmittedPos ? lastEmittedPos[axis] : 0)) > gridLabelDistance;\n    // And if there is also some minium distance from the very last position.\n    const isFarEnoughFromLast =\n        !isLast && Math.abs(positions[positions.length - 1][axis] - pos[axis]) > gridLabelDistance;\n\n    if (isFirst || isLast || (isFarEnoughFromPrevious && isFarEnoughFromLast)) {\n      yield [i, pos];\n      lastEmittedPos = pos;\n    }\n  }\n}\n\nconst last = <T>(array: T[]) => array[array.length - 1];\nconst first = <T>(array: T[]) => array[0];\n\n/**\n * Massage the list of line name positions given by the backend for easier consumption.\n */\nfunction normalizeNameData(namePositions: {name: string, x: number, y: number}[]):\n    {positions: {x: number, y: number}[], names: string[][]} {\n  const positions = [];\n  const names = [];\n\n  for (const {name, x, y} of namePositions) {\n    const normalizedX = Math.round(x);\n    const normalizedY = Math.round(y);\n\n    // If the same position already exists, just add the name to the existing entry, as there can be\n    // several custom names for a single line.\n    const existingIndex = positions.findIndex(({x, y}) => x === normalizedX && y === normalizedY);\n    if (existingIndex > -1) {\n      names[existingIndex].push(name);\n    } else {\n      positions.push({x: normalizedX, y: normalizedY});\n      names.push([name]);\n    }\n  }\n\n  return {positions, names};\n}\n\nexport interface NormalizePositionDataConfig {\n  positiveRowLineNumberPositions?: Position[];\n  negativeRowLineNumberPositions?: Position[];\n  positiveColumnLineNumberPositions?: Position[];\n  negativeColumnLineNumberPositions?: Position[];\n  rowLineNameOffsets?: {name: string, x: number, y: number}[];\n  columnLineNameOffsets?: {name: string, x: number, y: number}[];\n  gridHighlightConfig?: {showLineNames: boolean};\n}\n\n/**\n * Take the highlight config and bound objects in, and spits out an object with\n * the same information, but with 2 key differences:\n * - the information is organized in a way that makes the rest of the code more\n *   readable\n * - all pixel values are rounded to integers in order to safely compare\n *   positions (on high-dpi monitors floats are passed by the backend, this means\n *   checking if a position is at either edges of the container can't be done).\n */\nexport function normalizePositionData(config: NormalizePositionDataConfig, bounds: Bounds): GridPositionNormalizedData {\n  const width = Math.round(bounds.maxX - bounds.minX);\n  const height = Math.round(bounds.maxY - bounds.minY);\n\n  const data = {\n    rows: {\n      positive: {positions: [] as Position[], hasFirst: false, hasLast: false},\n      negative: {positions: [] as Position[], hasFirst: false, hasLast: false},\n    },\n    columns: {\n      positive: {positions: [] as Position[], hasFirst: false, hasLast: false},\n      negative: {positions: [] as Position[], hasFirst: false, hasLast: false},\n    },\n    bounds: {\n      minX: Math.round(bounds.minX),\n      maxX: Math.round(bounds.maxX),\n      minY: Math.round(bounds.minY),\n      maxY: Math.round(bounds.maxY),\n      allPoints: bounds.allPoints,\n      width,\n      height,\n    },\n  };\n\n  // Line numbers and line names can't be shown together at once for now.\n  // If showLineNames is set to true, then don't show line numbers, even if the\n  // data is present.\n\n  if (config.gridHighlightConfig && config.gridHighlightConfig.showLineNames) {\n    const rowData = normalizeNameData(config.rowLineNameOffsets || []);\n    const positiveRows: PositionDataWithNames = {\n      positions: rowData.positions,\n      names: rowData.names,\n      hasFirst: rowData.positions.length ? first(rowData.positions).y === data.bounds.minY : false,\n      hasLast: rowData.positions.length ? last(rowData.positions).y === data.bounds.maxY : false,\n    };\n    data.rows.positive = positiveRows;\n\n    const columnData = normalizeNameData(config.columnLineNameOffsets || []);\n    const positiveColumns: PositionDataWithNames = {\n      positions: columnData.positions,\n      names: columnData.names,\n      hasFirst: columnData.positions.length ? first(columnData.positions).x === data.bounds.minX : false,\n      hasLast: columnData.positions.length ? last(columnData.positions).x === data.bounds.maxX : false,\n    };\n    data.columns.positive = positiveColumns;\n  } else {\n    const normalizeXY = ({x, y}: {x: number, y: number}) => ({x: Math.round(x), y: Math.round(y)});\n    // TODO (alexrudenko): hasFirst & hasLast checks won't probably work for rotated grids.\n    if (config.positiveRowLineNumberPositions) {\n      data.rows.positive = {\n        positions: config.positiveRowLineNumberPositions.map(normalizeXY),\n        hasFirst: Math.round(first(config.positiveRowLineNumberPositions).y) === data.bounds.minY,\n        hasLast: Math.round(last(config.positiveRowLineNumberPositions).y) === data.bounds.maxY,\n      };\n    }\n\n    if (config.negativeRowLineNumberPositions) {\n      data.rows.negative = {\n        positions: config.negativeRowLineNumberPositions.map(normalizeXY),\n        hasFirst: Math.round(first(config.negativeRowLineNumberPositions).y) === data.bounds.minY,\n        hasLast: Math.round(last(config.negativeRowLineNumberPositions).y) === data.bounds.maxY,\n      };\n    }\n\n    if (config.positiveColumnLineNumberPositions) {\n      data.columns.positive = {\n        positions: config.positiveColumnLineNumberPositions.map(normalizeXY),\n        hasFirst: Math.round(first(config.positiveColumnLineNumberPositions).x) === data.bounds.minX,\n        hasLast: Math.round(last(config.positiveColumnLineNumberPositions).x) === data.bounds.maxX,\n      };\n    }\n\n    if (config.negativeColumnLineNumberPositions) {\n      data.columns.negative = {\n        positions: config.negativeColumnLineNumberPositions.map(normalizeXY),\n        hasFirst: Math.round(first(config.negativeColumnLineNumberPositions).x) === data.bounds.minX,\n        hasLast: Math.round(last(config.negativeColumnLineNumberPositions).x) === data.bounds.maxX,\n      };\n    }\n  }\n\n  return data;\n}\n\n/**\n * Places the grid row and column number labels on the overlay.\n *\n * @param {HTMLElement} container Where to append the labels\n * @param {GridPositionNormalizedData} data The grid line number data\n * @param {DOMMatrix=} writingModeMatrix The transformation matrix in case a vertical writing-mode is applied, to map label positions\n * @param {string=} writingMode The current writing-mode value\n */\nexport function drawGridLineNumbers(\n    container: HTMLElement, data: GridPositionNormalizedData, canvasSize: CanvasSize, emulationScaleFactor: number,\n    writingModeMatrix: DOMMatrix|undefined = new DOMMatrix(), writingMode: string|undefined = 'horizontal-tb') {\n  if (!data.columns.positive.names) {\n    for (const [i, pos] of positionIterator(data.columns.positive.positions, 'x')) {\n      const element = createLabelElement(container, (i + 1).toString(), 'column');\n      placePositiveColumnLabel(\n          element, applyMatrixToPoint(pos, writingModeMatrix), data, writingMode, canvasSize, emulationScaleFactor);\n    }\n  }\n\n  if (!data.rows.positive.names) {\n    for (const [i, pos] of positionIterator(data.rows.positive.positions, 'y')) {\n      const element = createLabelElement(container, (i + 1).toString(), 'row');\n      placePositiveRowLabel(\n          element, applyMatrixToPoint(pos, writingModeMatrix), data, writingMode, canvasSize, emulationScaleFactor);\n    }\n  }\n\n  for (const [i, pos] of positionIterator(data.columns.negative.positions, 'x')) {\n    // Negative positions are sorted such that the first position corresponds to the line closest to start edge of the grid.\n    const element =\n        createLabelElement(container, (data.columns.negative.positions.length * -1 + i).toString(), 'column');\n    placeNegativeColumnLabel(\n        element, applyMatrixToPoint(pos, writingModeMatrix), data, writingMode, canvasSize, emulationScaleFactor);\n  }\n\n  for (const [i, pos] of positionIterator(data.rows.negative.positions, 'y')) {\n    // Negative positions are sorted such that the first position corresponds to the line closest to start edge of the grid.\n    const element = createLabelElement(container, (data.rows.negative.positions.length * -1 + i).toString(), 'row');\n    placeNegativeRowLabel(\n        element, applyMatrixToPoint(pos, writingModeMatrix), data, writingMode, canvasSize, emulationScaleFactor);\n  }\n}\n\n/**\n * Places the grid track size labels on the overlay.\n */\nexport function drawGridTrackSizes(\n    container: HTMLElement, trackSizes: Array<TrackSize>, direction: 'row'|'column', canvasSize: CanvasSize,\n    emulationScaleFactor: number, writingModeMatrix: DOMMatrix|undefined = new DOMMatrix(),\n    writingMode: string|undefined = 'horizontal-tb') {\n  const {main, cross} = getAxes(writingMode);\n  const {crossSize} = getCanvasSizes(writingMode, canvasSize);\n\n  for (const {x, y, computedSize, authoredSize} of trackSizes) {\n    const point = applyMatrixToPoint({x, y}, writingModeMatrix);\n\n    const size = computedSize.toFixed(2);\n    const formattedComputed = `${size.endsWith('.00') ? size.slice(0, -3) : size}px`;\n    const element =\n        createLabelElement(container, `${authoredSize ? authoredSize + 'Â·' : ''}${formattedComputed}`, direction);\n    const labelSize = getLabelSize(element, writingMode);\n\n    let flipIn = point[main] - labelSize.mainSize < gridPageMargin;\n    if (direction === 'column') {\n      flipIn = writingMode === 'vertical-rl' ? crossSize - point[cross] - labelSize.crossSize < gridPageMargin :\n                                               point[cross] - labelSize.crossSize < gridPageMargin;\n    }\n\n    let arrowType = adaptArrowTypeForWritingMode(\n        direction === 'column' ? GridArrowTypes.bottomMid : GridArrowTypes.rightMid, writingMode);\n    arrowType = flipArrowTypeIfNeeded(arrowType, flipIn);\n\n    placeLineLabel(element, arrowType, point.x, point.y, labelSize, emulationScaleFactor);\n  }\n}\n\n/**\n * Places the grid row and column name labels on the overlay.\n */\nexport function drawGridLineNames(\n    container: HTMLElement, data: GridPositionNormalizedDataWithNames, canvasSize: CanvasSize,\n    emulationScaleFactor: number, writingModeMatrix: DOMMatrix|undefined = new DOMMatrix(),\n    writingMode: string|undefined = 'horizontal-tb') {\n  for (const [i, pos] of data.columns.positive.positions.entries()) {\n    const names = data.columns.positive.names[i];\n    const element = createLabelElement(container, makeLineNameLabelContent(names), 'column');\n    placePositiveColumnLabel(\n        element, applyMatrixToPoint(pos, writingModeMatrix), data, writingMode, canvasSize, emulationScaleFactor);\n  }\n\n  for (const [i, pos] of data.rows.positive.positions.entries()) {\n    const names = data.rows.positive.names[i];\n    const element = createLabelElement(container, makeLineNameLabelContent(names), 'row');\n    placePositiveRowLabel(\n        element, applyMatrixToPoint(pos, writingModeMatrix), data, writingMode, canvasSize, emulationScaleFactor);\n  }\n}\n\n/**\n * Turn an array of custom line names into DOM content that can be used in a label.\n */\nfunction makeLineNameLabelContent(names: string[]): HTMLElement {\n  const content = document.createElement('ul');\n  const namesToDisplay = names.slice(0, maxLineNamesCount);\n\n  for (const name of namesToDisplay) {\n    createChild(content, 'li', 'line-name').textContent = name;\n  }\n\n  return content;\n}\n\n/**\n * Places the grid area name labels on the overlay.\n */\nexport function drawGridAreaNames(\n    container: HTMLElement, areaBounds: AreaBounds[], writingModeMatrix: DOMMatrix|undefined = new DOMMatrix(),\n    writingMode: string|undefined = 'horizontal-tb') {\n  for (const {name, bounds} of areaBounds) {\n    const element = createLabelElement(container, name, 'row');\n    const {width, height} = getLabelSize(element, writingMode);\n\n    // The list of all points comes from the path created by the backend. This path is a rectangle with its starting point being\n    // the top left corner, which is where we want to place the label (except for vertical-rl writing-mode).\n    const point = writingMode === 'vertical-rl' ? bounds.allPoints[3] : bounds.allPoints[0];\n    const corner = applyMatrixToPoint(point, writingModeMatrix);\n\n    const flipX = bounds.allPoints[1].x < bounds.allPoints[0].x;\n    const flipY = bounds.allPoints[3].y < bounds.allPoints[0].y;\n    element.style.left = (corner.x - (flipX ? width : 0)) + 'px';\n    element.style.top = (corner.y - (flipY ? height : 0)) + 'px';\n  }\n}\n\n/**\n * Create the necessary DOM for a single label element.\n */\nfunction createLabelElement(\n    container: HTMLElement, textContent: string|HTMLElement, direction: 'row'|'column'): HTMLElement {\n  const wrapper = createChild(container, 'div');\n  const element = createChild(wrapper, 'div', 'grid-label-content');\n  element.dataset.direction = direction;\n\n  if (typeof textContent === 'string') {\n    element.textContent = textContent;\n  } else {\n    element.appendChild(textContent);\n  }\n\n  return element;\n}\n\n/**\n * Get the start and end points of the edge where labels are displayed.\n */\nfunction getLabelSideEdgePoints(\n    gridBounds: Bounds, direction: string, side: string): {start: {x: number, y: number}, end: {x: number, y: number}} {\n  const [p1, p2, p3, p4] = gridBounds.allPoints;\n\n  // Here are where all the points are in standard, untransformed, horizontal-tb mode:\n  // p1                        p2\n  //   +----------------------+\n  //   |                      |\n  //   +----------------------+\n  // p4                        p3\n\n  if (direction === 'row') {\n    return side === 'positive' ? {start: p1, end: p4} : {start: p2, end: p3};\n  }\n\n  return side === 'positive' ? {start: p1, end: p2} : {start: p4, end: p3};\n}\n\n/**\n * Get the name of the main and cross axes depending on the writing mode.\n * In \"normal\" horizonta-tb mode, the main axis is the one that goes horizontally from left to right,\n * hence, the x axis.\n * In vertical writing modes, the axes are swapped.\n */\nfunction getAxes(writingMode: string): {main: 'x'|'y', cross: 'x'|'y'} {\n  return writingMode.startsWith('vertical') ? {main: 'y', cross: 'x'} : {main: 'x', cross: 'y'};\n}\n\n/**\n * Get the main and cross sizes of the canvas area depending on the writing mode.\n * In \"normal\" horizonta-tb mode, the main axis is the one that goes horizontally from left to right,\n * hence, the main size of the canvas is its width, and its cross size is its height.\n * In vertical writing modes, those sizes are swapped.\n */\nfunction getCanvasSizes(writingMode: string, canvasSize: CanvasSize): {mainSize: number, crossSize: number} {\n  return writingMode.startsWith('vertical') ? {mainSize: canvasSize.canvasHeight, crossSize: canvasSize.canvasWidth} :\n                                              {mainSize: canvasSize.canvasWidth, crossSize: canvasSize.canvasHeight};\n}\n\n/**\n * Determine the position of a positive row label, and place it.\n */\nfunction placePositiveRowLabel(\n    element: HTMLElement, pos: Position, data: GridPositionNormalizedData, writingMode: string, canvasSize: CanvasSize,\n    emulationScaleFactor: number) {\n  const {start, end} = getLabelSideEdgePoints(data.bounds, 'row', 'positive');\n  const {main, cross} = getAxes(writingMode);\n  const {crossSize} = getCanvasSizes(writingMode, canvasSize);\n  const labelSize = getLabelSize(element, writingMode);\n\n  const isAtSharedStartCorner = pos[cross] === start[cross] && data.columns && data.columns.positive.hasFirst;\n  const isAtSharedEndCorner = pos[cross] === end[cross] && data.columns && data.columns.negative.hasFirst;\n  const isTooCloseToViewportStart = pos[cross] < gridPageMargin;\n  const isTooCloseToViewportEnd = crossSize - pos[cross] < gridPageMargin;\n  const flipIn = pos[main] - labelSize.mainSize < gridPageMargin;\n\n  if (flipIn && (isAtSharedStartCorner || isAtSharedEndCorner)) {\n    element.classList.add('inner-shared-corner');\n  }\n\n  let arrowType = adaptArrowTypeForWritingMode(GridArrowTypes.rightMid, writingMode);\n  if (isTooCloseToViewportStart || isAtSharedStartCorner) {\n    arrowType = adaptArrowTypeForWritingMode(GridArrowTypes.rightTop, writingMode);\n  } else if (isTooCloseToViewportEnd || isAtSharedEndCorner) {\n    arrowType = adaptArrowTypeForWritingMode(GridArrowTypes.rightBottom, writingMode);\n  }\n  arrowType = flipArrowTypeIfNeeded(arrowType, flipIn);\n\n  placeLineLabel(element, arrowType, pos.x, pos.y, labelSize, emulationScaleFactor);\n}\n\n/**\n * Determine the position of a negative row label, and place it.\n */\nfunction placeNegativeRowLabel(\n    element: HTMLElement, pos: Position, data: GridPositionNormalizedData, writingMode: string, canvasSize: CanvasSize,\n    emulationScaleFactor: number) {\n  const {start, end} = getLabelSideEdgePoints(data.bounds, 'row', 'negative');\n  const {main, cross} = getAxes(writingMode);\n  const {mainSize, crossSize} = getCanvasSizes(writingMode, canvasSize);\n  const labelSize = getLabelSize(element, writingMode);\n\n  const isAtSharedStartCorner = pos[cross] === start[cross] && data.columns && data.columns.positive.hasLast;\n  const isAtSharedEndCorner = pos[cross] === end[cross] && data.columns && data.columns.negative.hasLast;\n  const isTooCloseToViewportStart = pos[cross] < gridPageMargin;\n  const isTooCloseToViewportEnd = crossSize - pos[cross] < gridPageMargin;\n  const flipIn = mainSize - pos[main] - labelSize.mainSize < gridPageMargin;\n\n  if (flipIn && (isAtSharedStartCorner || isAtSharedEndCorner)) {\n    element.classList.add('inner-shared-corner');\n  }\n\n  let arrowType = adaptArrowTypeForWritingMode(GridArrowTypes.leftMid, writingMode);\n  if (isTooCloseToViewportStart || isAtSharedStartCorner) {\n    arrowType = adaptArrowTypeForWritingMode(GridArrowTypes.leftTop, writingMode);\n  } else if (isTooCloseToViewportEnd || isAtSharedEndCorner) {\n    arrowType = adaptArrowTypeForWritingMode(GridArrowTypes.leftBottom, writingMode);\n  }\n  arrowType = flipArrowTypeIfNeeded(arrowType, flipIn);\n\n  placeLineLabel(element, arrowType, pos.x, pos.y, labelSize, emulationScaleFactor);\n}\n\n/**\n * Determine the position of a positive column label, and place it.\n */\nfunction placePositiveColumnLabel(\n    element: HTMLElement, pos: Position, data: GridPositionNormalizedData, writingMode: string, canvasSize: CanvasSize,\n    emulationScaleFactor: number) {\n  const {start, end} = getLabelSideEdgePoints(data.bounds, 'column', 'positive');\n  const {main, cross} = getAxes(writingMode);\n  const {mainSize, crossSize} = getCanvasSizes(writingMode, canvasSize);\n  const labelSize = getLabelSize(element, writingMode);\n\n  const isAtSharedStartCorner = pos[main] === start[main] && data.rows && data.rows.positive.hasFirst;\n  const isAtSharedEndCorner = pos[main] === end[main] && data.rows && data.rows.negative.hasFirst;\n  const isTooCloseToViewportStart = pos[main] < gridPageMargin;\n  const isTooCloseToViewportEnd = mainSize - pos[main] < gridPageMargin;\n  const flipIn = writingMode === 'vertical-rl' ? crossSize - pos[cross] - labelSize.crossSize < gridPageMargin :\n                                                 pos[cross] - labelSize.crossSize < gridPageMargin;\n\n  if (flipIn && (isAtSharedStartCorner || isAtSharedEndCorner)) {\n    element.classList.add('inner-shared-corner');\n  }\n\n  let arrowType = adaptArrowTypeForWritingMode(GridArrowTypes.bottomMid, writingMode);\n  if (isTooCloseToViewportStart) {\n    arrowType = adaptArrowTypeForWritingMode(GridArrowTypes.bottomLeft, writingMode);\n  } else if (isTooCloseToViewportEnd) {\n    arrowType = adaptArrowTypeForWritingMode(GridArrowTypes.bottomRight, writingMode);\n  }\n\n  arrowType = flipArrowTypeIfNeeded(arrowType, flipIn);\n\n  placeLineLabel(element, arrowType, pos.x, pos.y, labelSize, emulationScaleFactor);\n}\n\n/**\n * Determine the position of a negative column label, and place it.\n */\nfunction placeNegativeColumnLabel(\n    element: HTMLElement, pos: Position, data: GridPositionNormalizedData, writingMode: string, canvasSize: CanvasSize,\n    emulationScaleFactor: number) {\n  const {start, end} = getLabelSideEdgePoints(data.bounds, 'column', 'negative');\n  const {main, cross} = getAxes(writingMode);\n  const {mainSize, crossSize} = getCanvasSizes(writingMode, canvasSize);\n  const labelSize = getLabelSize(element, writingMode);\n\n  const isAtSharedStartCorner = pos[main] === start[main] && data.rows && data.rows.positive.hasLast;\n  const isAtSharedEndCorner = pos[main] === end[main] && data.rows && data.rows.negative.hasLast;\n  const isTooCloseToViewportStart = pos[main] < gridPageMargin;\n  const isTooCloseToViewportEnd = mainSize - pos[main] < gridPageMargin;\n  const flipIn = writingMode === 'vertical-rl' ? pos[cross] - labelSize.crossSize < gridPageMargin :\n                                                 crossSize - pos[cross] - labelSize.crossSize < gridPageMargin;\n\n  if (flipIn && (isAtSharedStartCorner || isAtSharedEndCorner)) {\n    element.classList.add('inner-shared-corner');\n  }\n\n  let arrowType = adaptArrowTypeForWritingMode(GridArrowTypes.topMid, writingMode);\n  if (isTooCloseToViewportStart) {\n    arrowType = adaptArrowTypeForWritingMode(GridArrowTypes.topLeft, writingMode);\n  } else if (isTooCloseToViewportEnd) {\n    arrowType = adaptArrowTypeForWritingMode(GridArrowTypes.topRight, writingMode);\n  }\n  arrowType = flipArrowTypeIfNeeded(arrowType, flipIn);\n\n  placeLineLabel(element, arrowType, pos.x, pos.y, labelSize, emulationScaleFactor);\n}\n\n/**\n * Correctly place a line label element in the page. The given coordinates are\n * the ones where the arrow of the label needs to point.\n * Therefore, the width of the text in the label, and the position of the arrow\n * relative to the label are taken into account here to calculate the final x\n * and y coordinates of the label DOM element.\n */\nfunction placeLineLabel(\n    element: HTMLElement, arrowType: string, x: number, y: number, labelSize: LabelSize, emulationScaleFactor: number) {\n  const {contentLeft, contentTop} =\n      getLabelPositionByArrowType(arrowType, x, y, labelSize.width, labelSize.height, emulationScaleFactor);\n\n  element.classList.add(arrowType);\n  element.style.left = contentLeft + 'px';\n  element.style.top = contentTop + 'px';\n}\n\n/**\n * Given a label element, return its width and height, as well as what the main and cross sizes are depending on\n * the current writing mode.\n */\nfunction getLabelSize(element: HTMLElement, writingMode: string): LabelSize {\n  const width = getAdjustedLabelWidth(element);\n  const height = element.getBoundingClientRect().height;\n  const mainSize = writingMode.startsWith('vertical') ? height : width;\n  const crossSize = writingMode.startsWith('vertical') ? width : height;\n\n  return {width, height, mainSize, crossSize};\n}\n\n/**\n * Forces the width of the provided grid label element to be an even\n * number of pixels to allow centered placement of the arrow\n */\nfunction getAdjustedLabelWidth(element: HTMLElement) {\n  let labelWidth = element.getBoundingClientRect().width;\n  if (labelWidth % 2 === 1) {\n    labelWidth += 1;\n    element.style.width = labelWidth + 'px';\n  }\n  return labelWidth;\n}\n\n/**\n * In some cases, a label doesn't fit where it's supposed to be displayed.\n * This happens when it's too close to the edge of the viewport. When it does,\n * the label's position is flipped so that instead of being outside the grid, it\n * moves inside the grid.\n *\n * Example of a leftMid arrowType, which is by default outside the grid:\n *  -----------------------------\n * |                             |   +------+\n * |                             |   |      |\n * |-----------------------------|  <       |\n * |                             |   |      |\n * |                             |   +------+\n *  -----------------------------\n * When flipped, the label will be drawn inside the grid, so the arrow now needs\n * to point the other way:\n *  -----------------------------\n * |                  +------+   |\n * |                  |      |   |\n * |------------------|       >--|\n * |                  |      |   |\n * |                  +------+   |\n *  -----------------------------\n */\nfunction flipArrowTypeIfNeeded(arrowType: string, flipIn: boolean): string {\n  if (!flipIn) {\n    return arrowType;\n  }\n\n  switch (arrowType) {\n    case GridArrowTypes.leftTop:\n      return GridArrowTypes.rightTop;\n    case GridArrowTypes.leftMid:\n      return GridArrowTypes.rightMid;\n    case GridArrowTypes.leftBottom:\n      return GridArrowTypes.rightBottom;\n    case GridArrowTypes.rightTop:\n      return GridArrowTypes.leftTop;\n    case GridArrowTypes.rightMid:\n      return GridArrowTypes.leftMid;\n    case GridArrowTypes.rightBottom:\n      return GridArrowTypes.leftBottom;\n    case GridArrowTypes.topLeft:\n      return GridArrowTypes.bottomLeft;\n    case GridArrowTypes.topMid:\n      return GridArrowTypes.bottomMid;\n    case GridArrowTypes.topRight:\n      return GridArrowTypes.bottomRight;\n    case GridArrowTypes.bottomLeft:\n      return GridArrowTypes.topLeft;\n    case GridArrowTypes.bottomMid:\n      return GridArrowTypes.topMid;\n    case GridArrowTypes.bottomRight:\n      return GridArrowTypes.topRight;\n  }\n\n  return arrowType;\n}\n\n/**\n * Given an arrow type for the standard horizontal-tb writing-mode, return the corresponding type for a differnet\n * writing-mode.\n */\nfunction adaptArrowTypeForWritingMode(arrowType: string, writingMode: string): string {\n  if (writingMode === 'vertical-lr') {\n    switch (arrowType) {\n      case GridArrowTypes.leftTop:\n        return GridArrowTypes.topLeft;\n      case GridArrowTypes.leftMid:\n        return GridArrowTypes.topMid;\n      case GridArrowTypes.leftBottom:\n        return GridArrowTypes.topRight;\n      case GridArrowTypes.topLeft:\n        return GridArrowTypes.leftTop;\n      case GridArrowTypes.topMid:\n        return GridArrowTypes.leftMid;\n      case GridArrowTypes.topRight:\n        return GridArrowTypes.leftBottom;\n      case GridArrowTypes.rightTop:\n        return GridArrowTypes.bottomRight;\n      case GridArrowTypes.rightMid:\n        return GridArrowTypes.bottomMid;\n      case GridArrowTypes.rightBottom:\n        return GridArrowTypes.bottomLeft;\n      case GridArrowTypes.bottomLeft:\n        return GridArrowTypes.rightTop;\n      case GridArrowTypes.bottomMid:\n        return GridArrowTypes.rightMid;\n      case GridArrowTypes.bottomRight:\n        return GridArrowTypes.rightBottom;\n    }\n  }\n\n  if (writingMode === 'vertical-rl') {\n    switch (arrowType) {\n      case GridArrowTypes.leftTop:\n        return GridArrowTypes.topRight;\n      case GridArrowTypes.leftMid:\n        return GridArrowTypes.topMid;\n      case GridArrowTypes.leftBottom:\n        return GridArrowTypes.topLeft;\n      case GridArrowTypes.topLeft:\n        return GridArrowTypes.rightTop;\n      case GridArrowTypes.topMid:\n        return GridArrowTypes.rightMid;\n      case GridArrowTypes.topRight:\n        return GridArrowTypes.rightBottom;\n      case GridArrowTypes.rightTop:\n        return GridArrowTypes.bottomRight;\n      case GridArrowTypes.rightMid:\n        return GridArrowTypes.bottomMid;\n      case GridArrowTypes.rightBottom:\n        return GridArrowTypes.bottomLeft;\n      case GridArrowTypes.bottomLeft:\n        return GridArrowTypes.leftTop;\n      case GridArrowTypes.bottomMid:\n        return GridArrowTypes.leftMid;\n      case GridArrowTypes.bottomRight:\n        return GridArrowTypes.leftBottom;\n    }\n  }\n\n  return arrowType;\n}\n\n/**\n * Returns the required properties needed to place a label arrow based on the\n * arrow type and dimensions of the label\n */\nfunction getLabelPositionByArrowType(\n    arrowType: string, x: number, y: number, labelWidth: number, labelHeight: number,\n    emulationScaleFactor: number): {contentTop: number, contentLeft: number} {\n  let contentTop = 0;\n  let contentLeft = 0;\n  x *= emulationScaleFactor;\n  y *= emulationScaleFactor;\n  switch (arrowType) {\n    case GridArrowTypes.leftTop:\n      contentTop = y;\n      contentLeft = x + gridArrowWidth;\n      break;\n    case GridArrowTypes.leftMid:\n      contentTop = y - (labelHeight / 2);\n      contentLeft = x + gridArrowWidth;\n      break;\n    case GridArrowTypes.leftBottom:\n      contentTop = y - labelHeight;\n      contentLeft = x + gridArrowWidth;\n      break;\n    case GridArrowTypes.rightTop:\n      contentTop = y;\n      contentLeft = x - gridArrowWidth - labelWidth;\n      break;\n    case GridArrowTypes.rightMid:\n      contentTop = y - (labelHeight / 2);\n      contentLeft = x - gridArrowWidth - labelWidth;\n      break;\n    case GridArrowTypes.rightBottom:\n      contentTop = y - labelHeight;\n      contentLeft = x - labelWidth - gridArrowWidth;\n      break;\n    case GridArrowTypes.topLeft:\n      contentTop = y + gridArrowWidth;\n      contentLeft = x;\n      break;\n    case GridArrowTypes.topMid:\n      contentTop = y + gridArrowWidth;\n      contentLeft = x - (labelWidth / 2);\n      break;\n    case GridArrowTypes.topRight:\n      contentTop = y + gridArrowWidth;\n      contentLeft = x - labelWidth;\n      break;\n    case GridArrowTypes.bottomLeft:\n      contentTop = y - gridArrowWidth - labelHeight;\n      contentLeft = x;\n      break;\n    case GridArrowTypes.bottomMid:\n      contentTop = y - gridArrowWidth - labelHeight;\n      contentLeft = x - (labelWidth / 2);\n      break;\n    case GridArrowTypes.bottomRight:\n      contentTop = y - gridArrowWidth - labelHeight;\n      contentLeft = x - labelWidth;\n      break;\n  }\n  return {\n    contentTop,\n    contentLeft,\n  };\n}\n\n/**\n * Given a background color, generate a color for text to be legible.\n * This assumes the background color is given as either a \"rgba(r, g, b, a)\" string or a #rrggbb string.\n * This is because colors are sent by the backend using blink::Color:Serialized() which follows the logic for\n * serializing colors from https://html.spec.whatwg.org/#serialization-of-a-color\n *\n * In rgba form, the alpha channel is ignored.\n *\n * This is made to be small and fast and not require importing the entire Color utility from DevTools as it would make\n * the overlay bundle unnecessarily big.\n *\n * This is also made to generate the defaultLabelTextColor for all of the default label colors that the\n * OverlayColorGenerator produces.\n */\nexport function generateLegibleTextColor(backgroundColor: string) {\n  let rgb: number[] = [];\n\n  // Try to parse it as a #rrggbbaa string first\n  const rgba = parseHexa(backgroundColor + '00');\n  if (rgba.length === 4) {\n    rgb = rgba.slice(0, 3).map(c => c);\n  } else {\n    // Next try to parse as a rgba() string\n    const parsed = backgroundColor.match(/[0-9.]+/g);\n    if (!parsed) {\n      return null;\n    }\n    rgb = parsed.slice(0, 3).map(s => parseInt(s, 10) / 255);\n  }\n\n  if (!rgb.length) {\n    return null;\n  }\n\n  return luminance(rgb) > 0.2 ? defaultLabelTextColor : 'white';\n}\n"]}